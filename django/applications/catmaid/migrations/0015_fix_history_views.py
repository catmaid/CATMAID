# -*- coding: utf-8 -*-
# Generated by Django 1.9.10 on 2016-11-29 19:08

from django.db import migrations

# This fixes two function calls in history view and table construction:
#
#  - create_history_view_for_table() has one parameter instead of two
#  - initialize_new_history_table() expects three parameters instead of two
#
# Additionally, all to_regclass() method calls are changed so that now an
# argument of type 'text' is passed in, instead of 'cstring'. This is the new
# to_regclass signature of Postgres 9.6. In Postgres 9.5 a previously added
# compatibility function is used. For context, this is the original comment
# introducing those functions:
#
# Create view generating functions and a new version of the history table
# creation function, which implements history table initialization in a
# separate functions (which makes future changes easier). As part of this
# initialization there are now also views created. To make live tables match
# with their history tables, columns have to be specified explicitly. To not
# require the back-end to construct such queries, this is done in the database.
#
# View removal is not implemented explicitly as part of the
# drop_history_table() function, because CASCADE is used there, which already
# removes created views.
forward = """

    -- Return the unquoted name of a live table's combined live and history view
    CREATE OR REPLACE FUNCTION get_history_view_name(live_table_name regclass)
        RETURNS text AS
    $$
        SELECT relname || '__with_history' FROM pg_class WHERE oid = $1;
    $$ LANGUAGE sql STABLE;


    -- A function to create a unified history and live table view.
    CREATE OR REPLACE FUNCTION create_history_view_for_table(live_table regclass)
        RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        -- Make sure there is a history table
        IF NOT EXISTS(SELECT 1 FROM catmaid_history_table cht
                      WHERE cht.live_table = $1)
        THEN
            RAISE EXCEPTION 'Table % doesn''t have a history table', live_table;
        END IF;

        -- Drop existing view. Don't use CREATE OR REPLACE, because it only
        -- allows added columns, but no removed ones which might not work well
        -- with all table updates.
        EXECUTE format('DROP VIEW IF EXISTS %I', get_history_view_name(live_table));

        -- Create view that includes both live and history entries for a table.
        -- UNION ALL can be used, because we know live table and history tables
        -- have distinct rows.
        EXECUTE (
            SELECT format(
                'CREATE VIEW %1$s AS '
                '(SELECT %2$s FROM %3$s) '
                'UNION ALL '
                '(SELECT %2$s FROM %4$s) ',
                get_history_view_name(cht.live_table),
                string_agg(quote_ident(cti.column_name), ','),
                cht.live_table,
                cht.history_table)
            FROM catmaid_history_table cht
            JOIN catmaid_table_info cti
                ON cht.live_table = cti.rel_oid
            WHERE cht.live_table = $1
            GROUP BY cht.live_table);
    END;
    $$;


    -- A function to drop the history and live table view, makes it easier to
    -- use in regular queries.
    CREATE OR REPLACE FUNCTION drop_history_view_for_table(live_table regclass)
        RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        -- Try to Drop existing view
        EXECUTE format('DROP VIEW IF EXISTS %I', get_history_view_name(live_table));
    END;
    $$;


    -- Remove all entries from a (history) table.
    CREATE OR REPLACE FUNCTION truncate_history_table(target regclass)
        RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        EXECUTE "TRUNCATE TABLE %", target;
    END;
    $$;


    -- Remove all entries from all history tables.
    CREATE OR REPLACE FUNCTION truncate_all_history_tables()
        RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        EXECUTE (
            SELECT truncate_history_table(cht.history_table)
            FROM catmaid_history_table cht);
    END;
    $$;


    -- Create indices and views for a history table.
    CREATE OR REPLACE FUNCTION initialize_new_history_table(live_table regclass, history_table regclass,
        live_table_pkey_column text)
    RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        -- Create live table primary key index for the new history table. This
        -- is needed to quickly query older versions of an entity.
        IF (SELECT to_regclass(history_table || '_live_pk_index')) IS NULL THEN
            EXECUTE format(
                'CREATE INDEX %I ON %s (%s)',
                history_table || '_live_pk_index', history_table, live_table_pkey_column);
        END IF;

        -- Create sys_period (validity period) index for the new history
        -- table. This is needed to quickly query older state snapshots.
        IF (SELECT to_regclass(history_table || '_sys_period')) IS NULL THEN
            EXECUTE format(
                'CREATE INDEX %I ON %s USING gist(sys_period)',
                history_table || '_sys_period', history_table);
        END IF;

        -- Create index for transaction information, which is also needed to
        -- quickly find events that are part of the same transaction.
        IF (SELECT to_regclass(history_table || '_exec_transaction_id')) IS NULL THEN
            EXECUTE format(
                'CREATE INDEX %I ON %s (exec_transaction_id)',
                history_table || '_exec_transaction_id', history_table);
        END IF;

        -- Create history view
        PERFORM create_history_view_for_table(live_table);
    END;
    $$;


    -- Create a history table and triggers to populate it for the passed in table.
    -- Always use this function to create history tables to ensure everything is
    -- set up correctly. An optional time column and transaction ID column can be
    -- specified, which, if provided, will be used to obtain time information for a
    -- live row and its transaction ID. If no time column is passed in, an extra
    -- 1:1 table that tracks edition time and transactions of live table rows is
    -- created and used as a time and transaction source for individual live rows
    -- when needed.  Currently, only live tables with a single column primary key
    -- are supported.  If the passed in table inherits from another table and
    -- <copy_inheritance> is true (default), the history table will have the
    -- same inheritance hierarchy as the live table. All parent history tables
    -- are initialized as regular history tables, too. The optional
    -- <time_column> and <txid_column> either have both
    -- to be present or both NULL. If <sync> is true, the created history table
    -- (and potentially tracking table) is synchronized automatically, after it
    -- is created.
    CREATE OR REPLACE FUNCTION create_history_table(live_table regclass,
                                                    time_column text DEFAULT NULL,
                                                    txid_column text DEFAULT NULL,
                                                    create_triggers boolean DEFAULT true,
                                                    copy_inheritance boolean DEFAULT true,
                                                    sync boolean DEFAULT true)
    RETURNS void
    LANGUAGE plpgsql AS
    $$
    DECLARE

        -- This will contain the name of the newly created history table
        history_table_name text;

        -- This will contain a reference to the newly created history table
        history_table_oid regclass;

        -- If a time table is created, this contains the name of it
        tracking_table_name text;

        -- If a time table is created, this holds a reference to it.
        tracking_table_oid regclass;

        -- This will contain the name of a parent history table, if any
        parent_history_table_name text;

        -- A list of columns in the original table
        column_info record;

        -- A list of columns in a potential parent table
        parent_info record;

        -- The primary key of the live table
        live_table_pkey_column  text;
        live_table_pkey_type    text;
        live_table_n_pkeys      int;

    BEGIN

        -- History tables will be named like the live table plus a '_history' suffix
        history_table_name = get_history_table_name(live_table);

        -- Make sure the history table name is not longer than 63 characters, a
        -- limit that Postgres defaults to and which causes identifier names to
        -- become shortened silently.
        IF (LENGTH(get_history_update_fn_name_regular(live_table)) > 63) THEN
            RAISE EXCEPTION 'Can''t create history table with name longer than '
                '63 characters: %', history_table_name;
        END IF;

        -- Don't do anything if there is already a history table registered with this name.
        IF EXISTS(SELECT 1 FROM catmaid_history_table cht
            WHERE cht.history_table::text = history_table_name)
        THEN
            RAISE NOTICE 'History table ''%'' already exists', history_table_name;
            RETURN;
        END IF;

        -- Find primary key and type of table
        SELECT a.attname, format_type(a.atttypid, a.atttypmod)
        FROM   pg_index i
        JOIN   pg_attribute a ON a.attrelid = i.indrelid
                             AND a.attnum = ANY(i.indkey)
        WHERE  i.indrelid = live_table
        AND    i.indisprimary
        INTO live_table_pkey_column, live_table_pkey_type;

        GET DIAGNOSTICS live_table_n_pkeys = ROW_COUNT;


        -- Make sure there is a single-column primary key available on the live table.
        IF live_table_n_pkeys = 0 THEN
            RAISE EXCEPTION 'Need primary key on table to create history '
                'table for "%"', live_table;
        ELSIF live_table_n_pkeys > 1 THEN
            RAISE EXCEPTION 'Currently only single column primary keys are'
            'supported, the primary key of table "%" consists of % columns: %',
                live_table, live_table_n_pkeys, live_table_pkey_column;
        END IF;

        -- If a time column was provided, make sure there also a transaction
        -- column provided. And then make sure both exist.
        IF (time_column IS NULL AND txid_column IS NOT NULL) OR
           (time_column IS NOT NULL AND txid_column IS NULL)
        THEN
            RAISE EXCEPTION 'Either provide both time column name and '
                'transaction column name or none for table %', live_table;
        ELSIF (time_column IS NOT NULL AND txid_column IS NOT NULL)
        THEN
            IF NOT EXISTS(SELECT 1 FROM catmaid_table_info
                WHERE rel_oid = live_table AND column_name <> time_column)
            THEN
                RAISE EXCEPTION 'The time column % doesn''t exist in table %',
                    time_column, live_table;
            END IF;
            IF NOT EXISTS(SELECT 1 FROM catmaid_table_info
                WHERE rel_oid = live_table AND column_name <> txid_column)
            THEN
                RAISE EXCEPTION 'The transaction column % doesn''t exist in table %',
                    txid_column, live_table;
            END IF;
        END IF;

        -- Set parent information to nothing by default
        SELECT NULL INTO parent_info;

        -- Create new history table with the same columns as the original,
        -- but without indices or constraints. Parent tables are required to
        -- have regular history tables as well.
        IF copy_inheritance THEN
            -- If the table inherits from another table and <copy_inheritance> is
            -- true, the complete inheritance hierarchy will be recreated for the
            -- new table. Currently, only single table inheritance is supported.
            RAISE NOTICE 'START INHERITANCE for %', live_table;
            BEGIN
                SELECT parent_schemaname, parent_tablename, parent_oid INTO STRICT parent_info
                FROM catmaid_inheriting_tables
                WHERE child_oid = live_table;
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        -- Do nothing
                    WHEN TOO_MANY_ROWS THEN
                        -- Multi-inheritance support isn't implemented for history tables, yet
                        RAISE EXCEPTION 'Couldn''t create history table, found '
                                'more than one parent of "%s"', live_table;
            END;

            IF FOUND THEN
                RAISE NOTICE 'Setting up history tracking for parent: %, %, %',
                    parent_info.parent_schemaname, parent_info.parent_tablename,
                    parent_info.parent_oid;
                -- Recursively create a history table for the parent
                PERFORM create_history_table(parent_info.parent_oid, time_column,
                    txid_column, create_triggers, copy_inheritance, sync);
            END IF;
            RAISE NOTICE 'END INHERITANCE';
        END IF;

        IF parent_info IS NOT NULL THEN
            parent_history_table_name = get_history_table_name(parent_info.parent_oid);
            RAISE NOTICE 'CREATE History table with INHERITANCE %', parent_history_table_name;
            -- Create a history table that inherits from the previously created
            -- parent history table.
            EXECUTE format(
                'CREATE TABLE IF NOT EXISTS %I (LIKE %s) INHERITS (%I)',
                history_table_name, live_table, parent_history_table_name
            );
        ELSE
            -- Create a regular history table without inheritance, either
            -- because no parent is available or no parent check was performed.
            EXECUTE format(
                'CREATE TABLE IF NOT EXISTS %I (LIKE %s)',
                history_table_name, live_table
            );
        END IF;

        -- Get the OID of the new history table
        history_table_oid = to_regclass(history_table_name);

        -- Make all history columns (except the later added sys_period and
        -- transaction info columns) default to NULL.
        FOR column_info IN
            SELECT column_name
            FROM catmaid_table_info
            WHERE rel_oid = live_table
            AND column_name <> 'sys_period'
        LOOP
            -- Drop NOT NULL constraints and add default
            EXECUTE format(
                'ALTER TABLE %s ALTER COLUMN %I DROP NOT NULL',
                history_table_oid, column_info.column_name);
            EXECUTE format(
                'ALTER TABLE %s ALTER COLUMN %I SET DEFAULT NULL',
                history_table_oid, column_info.column_name);
        END LOOP;

        -- Add a system time column to the history table, named sys_period, if
        -- it doesn't exist already (which can happen due to table inheritance).
        IF NOT EXISTS(SELECT column_name
                      FROM catmaid_table_info
                      WHERE rel_oid = history_table_oid
                      AND column_name = 'sys_period') THEN
            EXECUTE format(
                'ALTER TABLE %s ADD COLUMN sys_period tstzrange
                NOT NULL DEFAULT tstzrange(current_timestamp, null)',
                history_table_oid
            );
        END IF;

        -- Add a transaction reference to the history table, named
        -- exec_transaction_id, if it doesn't exist already (which can
        -- happen due to table inheritance. Together with the lower part
        -- of the sys_period range, the transaction ID is unique.
        IF NOT EXISTS(SELECT column_name
                      FROM catmaid_table_info
                      WHERE rel_oid = history_table_oid
                      AND column_name = 'exec_transaction_id') THEN
            EXECUTE format(
                'ALTER TABLE %s ADD COLUMN exec_transaction_id bigint
                NOT NULL DEFAULT txid_current()',
                history_table_oid
            );
        END IF;


        -- Create a tracking table if no time column was provided. It will
        -- store the last edition time for each entry. Update triggers are
        -- created as part of the trigger enabling.
        IF time_column IS NULL THEN

            -- A foreign key reference to live table's PK isn't used, because
            -- it make is much easier to deal with TRUNCATE queries on the live
            -- table.
            tracking_table_name = get_tracking_table_name(live_table);
            EXECUTE format(
                'CREATE TABLE IF NOT EXISTS %s ('
                '  live_pk %s UNIQUE DEFERRABLE INITIALLY DEFERRED,'
                '  edition_time timestamptz NOT NULL,'
                '  txid bigint NOT NULL'
                ')',
                tracking_table_name, live_table_pkey_type);

            -- Get the OID of the new history table
            tracking_table_oid = to_regclass(tracking_table_name);

            -- Create ID index for quick look-ups when updating the tracking table
            IF (SELECT to_regclass(tracking_table_name || '_live_pk_index')) IS NULL THEN
                EXECUTE format(
                    'CREATE INDEX %I ON %s (%s)',
                    tracking_table_name || '_live_pk_index', tracking_table_oid, 'live_pk');
            END IF;

        ELSE
            SELECT NULL into tracking_table_oid;
        END IF;


        -- Keep track of created history tables
        INSERT INTO catmaid_history_table (history_table, live_table,
            triggers_installed, time_column, txid_column,
            live_table_pkey_column, tracking_table)
        VALUES (history_table_oid, live_table, false,
            COALESCE(time_column, 'edition_time'),
            COALESCE(txid_column, 'txid'),
            live_table_pkey_column, tracking_table_oid);

        -- Perform additional initialization like index and view generation
        PERFORM initialize_new_history_table(live_table, history_table_oid, live_table_pkey_column);

        -- Set up data insert, update and delete trigger on original database
        IF create_triggers THEN
            -- Handle sync separately, makes it easier to disable
            PERFORM enable_history_tracking_for_table(live_table,
                history_table_name, false);
        END IF;


        IF sync AND time_column IS NULL THEN
            RAISE NOTICE 'Syncing time for table "%" in tracking table "%"',
                live_table, tracking_table_oid;
            PERFORM sync_tracking_table(live_table, tracking_table_oid);
        END IF;
    END;
    $$;


    -- Remove an existing history table for the passed in table
    CREATE OR REPLACE FUNCTION drop_history_table(live_table regclass)
    RETURNS void
    LANGUAGE plpgsql AS
    $$
    DECLARE

        -- This will contain the name of the newly created history table. No
        -- regclass is used, because the implicit table existence check on variable
        -- assignment can fail if the table has already been removed by an
        -- cascaded table drop.
        history_table_name text;

    BEGIN

        -- History tables will be named like the live table plus a '__history' suffix
        history_table_name = get_history_table_name(live_table);

        -- Cascading deleting is used to also delete child tables and triggers.
        EXECUTE format('DROP TABLE IF EXISTS %I CASCADE', history_table_name);
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_tracking_table_update_trigger_name(), live_table);
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_tracking_table_truncate_trigger_name(), live_table);
        EXECUTE format('DROP TABLE IF EXISTS %I CASCADE',
            get_tracking_table_name(live_table));

        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_history_update_trigger_name_regular(), live_table);
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_history_update_trigger_name_tracking(), live_table);
        EXECUTE format('DROP FUNCTION IF EXISTS %s() CASCADE',
            get_history_update_fn_name_regular(live_table));
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_history_truncate_trigger_name(), live_table);

        -- Remove from created table log
        DELETE FROM catmaid_history_table cht WHERE cht.live_table = $1;
    END;
    $$;
"""

# Re-create old version of history table creation and drop new methods
backward = """

    -- Return the unquoted name of a live table's combined live and history view
    CREATE OR REPLACE FUNCTION get_history_view_name(live_table_name regclass)
        RETURNS text AS
    $$
        SELECT relname || '__with_history' FROM pg_class WHERE oid = $1;
    $$ LANGUAGE sql STABLE;

    -- A function to create a unified history and live table view.
    CREATE OR REPLACE FUNCTION create_history_view_for_table(live_table regclass)
        RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        -- Make sure there is a history table
        IF NOT EXISTS(SELECT 1 FROM catmaid_history_table cht
                      WHERE cht.live_table = $1)
        THEN
            RAISE EXCEPTION 'Table % doesn''t have a history table', live_table;
        END IF;

        -- Drop existing view. Don't use CREATE OR REPLACE, because it only
        -- allows added columns, but no removed once which might not work well
        -- with all table updates.
        EXECUTE format('DROP VIEW IF EXISTS %I', get_history_view_name(live_table));

        -- Create view that includes both live and history entries for a table.
        -- UNION ALL can be used, because we know live table and history tables
        -- have distinct rows.
        EXECUTE (
            SELECT format(
                'CREATE VIEW %1$s AS '
                '(SELECT %2$s FROM %3$s) '
                'UNION ALL '
                '(SELECT %2$s FROM %4$s) ',
                get_history_view_name(cht.live_table),
                string_agg(quote_ident(cti.column_name), ','),
                cht.live_table,
                cht.history_table)
            FROM catmaid_history_table cht
            JOIN catmaid_table_info cti
                ON cht.live_table = cti.rel_oid
            WHERE cht.live_table = $1
            GROUP BY cht.live_table);
    END;
    $$;

    -- A function to drop the history and live table view, makes it easier to
    -- use in regular queries.
    CREATE OR REPLACE FUNCTION drop_history_view_for_table(live_table regclass)
        RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        -- Try to Drop existing view
        EXECUTE format('DROP VIEW IF EXISTS %I', get_history_view_name(live_table));
    END;
    $$;


    -- Remove all entries from a (history) table.
    CREATE OR REPLACE FUNCTION truncate_history_table(target regclass)
        RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        EXECUTE "TRUNCATE TABLE %", target;
    END;
    $$;


    -- Remove all entries from all history tables.
    CREATE OR REPLACE FUNCTION truncate_all_history_tables()
        RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        EXECUTE (
            SELECT truncate_history_table(cht.history_table)
            FROM catmaid_history_table cht);
    END;
    $$;


    -- Create indices and views for a history table.
    CREATE OR REPLACE FUNCTION initialize_new_history_table(live_table regclass, history_table regclass,
        live_table_pkey_column text)
    RETURNS void
    LANGUAGE plpgsql AS
    $$
    BEGIN
        -- Create live table primary key index for the new history table. This
        -- is needed to quickly query older versions of an entity.
        IF (SELECT to_regclass((history_table || '_live_pk_index')::cstring)) IS NULL THEN
            EXECUTE format(
                'CREATE INDEX %I ON %s (%s)',
                history_table || '_live_pk_index', history_table, live_table_pkey_column);
        END IF;

        -- Create sys_period (validity period) index for the new history
        -- table. This is needed to quickly query older state snapshots.
        IF (SELECT to_regclass((history_table || '_sys_period')::cstring)) IS NULL THEN
            EXECUTE format(
                'CREATE INDEX %I ON %s USING gist(sys_period)',
                history_table || '_sys_period', history_table);
        END IF;

        -- Create index for transaction information, which is also needed to
        -- quickly find events that are part of the same transaction.
        IF (SELECT to_regclass((history_table || '_exec_transaction_id')::cstring)) IS NULL THEN
            EXECUTE format(
                'CREATE INDEX %I ON %s (exec_transaction_id)',
                history_table || '_exec_transaction_id', history_table);
        END IF;

        -- Create history view
        PERFORM create_history_view_for_table(live_table, history_table);
    END;
    $$;

    -- Create a history table and triggers to populate it for the passed in table.
    -- Always use this function to create history tables to ensure everything is
    -- set up correctly. An optional time column and transaction ID column can be
    -- specified, which, if provided, will be used to obtain time information for a
    -- live row and its transaction ID. If no time column is passed in, an extra
    -- 1:1 table that tracks edition time and transactions of live table rows is
    -- created and used as a time and transaction source for individual live rows
    -- when needed.  Currently, only live tables with a single column primary key
    -- are supported.  If the passed in table inherits from another table and
    -- <copy_inheritance> is true (default), the history table will have the
    -- same inheritance hierarchy as the live table. All parent history tables
    -- are initialized as regular history tables, too. The optional
    -- <time_column> and <txid_column> either have both
    -- to be present or both NULL. If <sync> is true, the created history table
    -- (and potentially tracking table) is synchronized automatically, after it
    -- is created.
    CREATE OR REPLACE FUNCTION create_history_table(live_table regclass,
                                                    time_column text DEFAULT NULL,
                                                    txid_column text DEFAULT NULL,
                                                    create_triggers boolean DEFAULT true,
                                                    copy_inheritance boolean DEFAULT true,
                                                    sync boolean DEFAULT true)
    RETURNS void
    LANGUAGE plpgsql AS
    $$
    DECLARE

        -- This will contain the name of the newly created history table
        history_table_name text;

        -- This will contain a reference to the newly created history table
        history_table_oid regclass;

        -- If a time table is created, this contains the name of it
        tracking_table_name text;

        -- If a time table is created, this holds a reference to it.
        tracking_table_oid regclass;

        -- This will contain the name of a parent history table, if any
        parent_history_table_name text;

        -- A list of columns in the original table
        column_info record;

        -- A list of columns in a potential parent table
        parent_info record;

        -- The primary key of the live table
        live_table_pkey_column  text;
        live_table_pkey_type    text;
        live_table_n_pkeys      int;

    BEGIN

        -- History tables will be named like the live table plus a '_history' suffix
        history_table_name = get_history_table_name(live_table);

        -- Make sure the history table name is not longer than 63 characters, a
        -- limit that Postgres defaults to and which causes identifier names to
        -- become shortened silently.
        IF (LENGTH(get_history_update_fn_name_regular(live_table)) > 63) THEN
            RAISE EXCEPTION 'Can''t create history table with name longer than '
                '63 characters: %', history_table_name;
        END IF;

        -- Don't do anything if there is already a history table registered with this name.
        IF EXISTS(SELECT 1 FROM catmaid_history_table cht
            WHERE cht.history_table::text = history_table_name)
        THEN
            RAISE NOTICE 'History table ''%'' already exists', history_table_name;
            RETURN;
        END IF;

        -- Find primary key and type of table
        SELECT a.attname, format_type(a.atttypid, a.atttypmod)
        FROM   pg_index i
        JOIN   pg_attribute a ON a.attrelid = i.indrelid
                             AND a.attnum = ANY(i.indkey)
        WHERE  i.indrelid = live_table
        AND    i.indisprimary
        INTO live_table_pkey_column, live_table_pkey_type;

        GET DIAGNOSTICS live_table_n_pkeys = ROW_COUNT;


        -- Make sure there is a single-column primary key available on the live table.
        IF live_table_n_pkeys = 0 THEN
            RAISE EXCEPTION 'Need primary key on table to create history '
                'table for "%"', live_table;
        ELSIF live_table_n_pkeys > 1 THEN
            RAISE EXCEPTION 'Currently only single column primary keys are'
            'supported, the primary key of table "%" consists of % columns: %',
                live_table, live_table_n_pkeys, live_table_pkey_column;
        END IF;

        -- If a time column was provided, make sure there also a transaction
        -- column provided. And then make sure both exist.
        IF (time_column IS NULL AND txid_column IS NOT NULL) OR
           (time_column IS NOT NULL AND txid_column IS NULL)
        THEN
            RAISE EXCEPTION 'Either provide both time column name and '
                'transaction column name or none for table %', live_table;
        ELSIF (time_column IS NOT NULL AND txid_column IS NOT NULL)
        THEN
            IF NOT EXISTS(SELECT 1 FROM catmaid_table_info
                WHERE rel_oid = live_table AND column_name <> time_column)
            THEN
                RAISE EXCEPTION 'The time column % doesn''t exist in table %',
                    time_column, live_table;
            END IF;
            IF NOT EXISTS(SELECT 1 FROM catmaid_table_info
                WHERE rel_oid = live_table AND column_name <> txid_column)
            THEN
                RAISE EXCEPTION 'The transaction column % doesn''t exist in table %',
                    txid_column, live_table;
            END IF;
        END IF;

        -- Set parent information to nothing by default
        SELECT NULL INTO parent_info;

        -- Create new history table with the same columns as the original,
        -- but without indices or constraints. Parent tables are required to
        -- have regular history tables as well.
        IF copy_inheritance THEN
            -- If the table inherits from another table and <copy_inheritance> is
            -- true, the complete inheritance hierarchy will be recreated for the
            -- new table. Currently, only single table inheritance is supported.
            RAISE NOTICE 'START INHERITANCE for %', live_table;
            BEGIN
                SELECT parent_schemaname, parent_tablename, parent_oid INTO STRICT parent_info
                FROM catmaid_inheriting_tables
                WHERE child_oid = live_table;
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        -- Do nothing
                    WHEN TOO_MANY_ROWS THEN
                        -- Multi-inheritance support isn't implemented for history tables, yet
                        RAISE EXCEPTION 'Couldn''t create history table, found '
                                'more than one parent of "%s"', live_table;
            END;

            IF FOUND THEN
                RAISE NOTICE 'Setting up history tracking for parent: %, %, %',
                    parent_info.parent_schemaname, parent_info.parent_tablename,
                    parent_info.parent_oid;
                -- Recursively create a history table for the parent
                PERFORM create_history_table(parent_info.parent_oid, time_column,
                    txid_column, create_triggers, copy_inheritance, sync);
            END IF;
            RAISE NOTICE 'END INHERITANCE';
        END IF;

        IF parent_info IS NOT NULL THEN
            parent_history_table_name = get_history_table_name(parent_info.parent_oid);
            RAISE NOTICE 'CREATE History table with INHERITANCE %', parent_history_table_name;
            -- Create a history table that inherits from the previously created
            -- parent history table.
            EXECUTE format(
                'CREATE TABLE IF NOT EXISTS %I (LIKE %s) INHERITS (%I)',
                history_table_name, live_table, parent_history_table_name
            );
        ELSE
            -- Create a regular history table without inheritance, either
            -- because no parent is available or no parent check was performed.
            EXECUTE format(
                'CREATE TABLE IF NOT EXISTS %I (LIKE %s)',
                history_table_name, live_table
            );
        END IF;

        -- Get the OID of the new history table
        history_table_oid = to_regclass(history_table_name::cstring);

        -- Make all history columns (except the later added sys_period and
        -- transaction info columns) default to NULL.
        FOR column_info IN
            SELECT column_name
            FROM catmaid_table_info
            WHERE rel_oid = live_table
            AND column_name <> 'sys_period'
        LOOP
            -- Drop NOT NULL constraints and add default
            EXECUTE format(
                'ALTER TABLE %s ALTER COLUMN %I DROP NOT NULL',
                history_table_oid, column_info.column_name);
            EXECUTE format(
                'ALTER TABLE %s ALTER COLUMN %I SET DEFAULT NULL',
                history_table_oid, column_info.column_name);
        END LOOP;

        -- Add a system time column to the history table, named sys_period, if
        -- it doesn't exist already (which can happen due to table inheritance).
        IF NOT EXISTS(SELECT column_name
                      FROM catmaid_table_info
                      WHERE rel_oid = history_table_oid
                      AND column_name = 'sys_period') THEN
            EXECUTE format(
                'ALTER TABLE %s ADD COLUMN sys_period tstzrange
                NOT NULL DEFAULT tstzrange(current_timestamp, null)',
                history_table_oid
            );
        END IF;

        -- Add a transaction reference to the history table, named
        -- exec_transaction_id, if it doesn't exist already (which can
        -- happen due to table inheritance. Together with the lower part
        -- of the sys_period range, the transaction ID is unique.
        IF NOT EXISTS(SELECT column_name
                      FROM catmaid_table_info
                      WHERE rel_oid = history_table_oid
                      AND column_name = 'exec_transaction_id') THEN
            EXECUTE format(
                'ALTER TABLE %s ADD COLUMN exec_transaction_id bigint
                NOT NULL DEFAULT txid_current()',
                history_table_oid
            );
        END IF;


        -- Create a tracking table if no time column was provided. It will
        -- store the last edition time for each entry. Update triggers are
        -- created as part of the trigger enabling.
        IF time_column IS NULL THEN

            -- A foreign key reference to live table's PK isn't used, because
            -- it make is much easier to deal with TRUNCATE queries on the live
            -- table.
            tracking_table_name = get_tracking_table_name(live_table);
            EXECUTE format(
                'CREATE TABLE IF NOT EXISTS %s ('
                '  live_pk %s UNIQUE DEFERRABLE INITIALLY DEFERRED,'
                '  edition_time timestamptz NOT NULL,'
                '  txid bigint NOT NULL'
                ')',
                tracking_table_name, live_table_pkey_type);

            -- Get the OID of the new history table
            tracking_table_oid = to_regclass(tracking_table_name::cstring);

            -- Create ID index for quick look-ups when updating the tracking table
            IF (SELECT to_regclass((tracking_table_name || '_live_pk_index')::cstring)) IS NULL THEN
                EXECUTE format(
                    'CREATE INDEX %I ON %s (%s)',
                    tracking_table_name || '_live_pk_index', tracking_table_oid, 'live_pk');
            END IF;

        ELSE
            SELECT NULL into tracking_table_oid;
        END IF;


        -- Keep track of created history tables
        INSERT INTO catmaid_history_table (history_table, live_table,
            triggers_installed, time_column, txid_column,
            live_table_pkey_column, tracking_table)
        VALUES (history_table_oid, live_table, false,
            COALESCE(time_column, 'edition_time'),
            COALESCE(txid_column, 'txid'),
            live_table_pkey_column, tracking_table_oid);

        -- Perform additional initialization like index and view generation
        PERFORM initialize_new_history_table(live_table, history_table_oid);

        -- Set up data insert, update and delete trigger on original database
        IF create_triggers THEN
            -- Handle sync separately, makes it easier to disable
            PERFORM enable_history_tracking_for_table(live_table,
                history_table_name, false);
        END IF;


        IF sync AND time_column IS NULL THEN
            RAISE NOTICE 'Syncing time for table "%" in tracking table "%"',
                live_table, tracking_table_oid;
            PERFORM sync_tracking_table(live_table, tracking_table_oid);
        END IF;
    END;
    $$;


    -- Remove an existing history table for the passed in table
    CREATE OR REPLACE FUNCTION drop_history_table(live_table regclass)
    RETURNS void
    LANGUAGE plpgsql AS
    $$
    DECLARE

        -- This will contain the name of the newly created history table. No
        -- regclass is used, because the implicit table existence check on variable
        -- assignment can fail if the table has already been removed by an
        -- cascaded table drop.
        history_table_name text;

    BEGIN

        -- History tables will be named like the live table plus a '__history' suffix
        history_table_name = get_history_table_name(live_table);

        -- Cascading deleting is used to also delete child tables and triggers.
        EXECUTE format('DROP TABLE IF EXISTS %I CASCADE', history_table_name);
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_tracking_table_update_trigger_name(), live_table);
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_tracking_table_truncate_trigger_name(), live_table);
        EXECUTE format('DROP TABLE IF EXISTS %I CASCADE',
            get_tracking_table_name(live_table));

        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_history_update_trigger_name_regular(), live_table);
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s',
            get_history_update_trigger_name_tracking(), live_table);
        EXECUTE format('DROP FUNCTION IF EXISTS %s() CASCADE',
            get_history_update_fn_name_regular(live_table));
        EXECUTE format('DROP FUNCTION IF EXISTS %s() CASCADE',
            get_history_truncate_trigger_name());

        -- Remove from created table log
        DELETE FROM catmaid_history_table cht WHERE cht.live_table = $1;
    END;
    $$;
"""

class Migration(migrations.Migration):

    dependencies = [
        ('catmaid', '0014_ensure_restriction_tables_have_auto_id'),
        ('performancetests', '0003_update_history_tables')
    ]

    operations = [
        migrations.RunSQL(forward, backward),
    ]
