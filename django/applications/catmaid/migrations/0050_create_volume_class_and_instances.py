# -*- coding: utf-8 -*-
# Generated by Django 1.11.14 on 2018-07-20 14:27
import logging

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone

from catmaid.apps import get_system_user


logger = logging.getLogger(__name__)


def forwards(apps, schema_editor):
    """Make sure all required class and relations are existing for all
    projects.  We can't use the regular model classes, but have to get
    them through the migration system.
    """
    from catmaid.control.project import validate_project_setup

    Class = apps.get_model('catmaid', 'Class')
    Project = apps.get_model('catmaid', 'Project')
    Relation = apps.get_model('catmaid', 'Relation')
    User = apps.get_model('auth', 'User')
    ClientDatastore = apps.get_model('catmaid', 'ClientDatastore')
    Volume = apps.get_model('catmaid', 'Volume')

    projects = Project.objects.all()
    # If there are no projects, don't continue, because there is nothing to
    # migrate.
    if 0 == len(projects) or 0 == User.objects.count():
        return

    try:
        system_user = get_system_user(User)
        for p in projects:
            validate_project_setup(p.id, system_user.id, True, Class, Relation, ClientDatastore)
    except ImproperlyConfigured as e:
        if Volume.objects.count() > 0:
            logger.warn("Couldn't find a configured system user and will therefore "
                    "skip a configuration update of all existing projects. This is "
                    "okay during the initial setup of a CATMAID database. In this "
                    "case nothing needs to be done. Otherwise, please run "
                    "`manage.py catmaid_update_project_configuration` manually "
                    "after this migration call is finished and rerun this migration.")
            raise e

forward_create_relations = """
    CREATE TABLE volume_class_instance (
        volume_id bigint NOT NULL,
        class_instance_id integer NOT NULL
    )
    INHERITS (relation_instance);

    -- Volume Class Instance constraints
    ALTER TABLE ONLY volume_class_instance
    ADD CONSTRAINT volume_class_instance_pkey PRIMARY KEY (id);

    ALTER TABLE ONLY volume_class_instance
    ADD CONSTRAINT volume_class_instance_sa_id
    FOREIGN KEY (volume_id)
    REFERENCES catmaid_volume(id) DEFERRABLE INITIALLY DEFERRED;

    ALTER TABLE ONLY volume_class_instance
    ADD CONSTRAINT volume_class_instance_id_fkey
    FOREIGN KEY (class_instance_id)
    REFERENCES class_instance(id) DEFERRABLE INITIALLY DEFERRED;

    WITH new_cis AS (
        INSERT INTO class_instance (user_id, project_id, name, class_id)
        SELECT
            v.user_id,
            v.project_id,
            v.name,
            c.id
        FROM catmaid_volume v
        JOIN class c ON (c.project_id = v.project_id AND c.class_name = 'volume')
        RETURNING id, user_id, project_id, name
    )
    INSERT INTO volume_class_instance (user_id, project_id, relation_id, volume_id, class_instance_id)
    SELECT
        v.user_id,
        v.project_id,
        r.id,
        v.id,
        ci.id
    FROM catmaid_volume v
    JOIN relation r ON (r.project_id = v.project_id AND r.relation_name = 'model_of')
    JOIN new_cis ci ON (
        ci.user_id = v.user_id AND
        ci.project_id = v.project_id AND
        ci.name = v.name
    );

    -- Create history tables
    SELECT create_history_table('volume_class_instance'::regclass, 'edition_time', 'txid');
"""

backward_create_relations = """
    SELECT disable_history_tracking_for_table('volume_class_instance'::regclass,
        get_history_table_name('volume_class_instance'::regclass));
    SELECT drop_history_table('volume_class_instance'::regclass);

    DROP TABLE volume_class_instance;

    DELETE FROM class_instance_class_instance cici
    USING class ca, class cb, class_instance cia, class_instance cib
    WHERE (cici.class_instance_a = cia.id
        OR cici.class_instance_b = cib.id)
        AND cia.class_id = ca.id
        AND cib.class_id = cb.id
        AND ca.class_name = 'volume'
        AND cb.class_name = 'volume';

    DELETE FROM class_instance
    USING class c
    WHERE class_instance.class_id = c.id
        AND c.class_name = 'volume';

"""


class Migration(migrations.Migration):

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ('catmaid', '0049_volume_tin_representation'),
    ]

    operations = [
        migrations.RunPython(forwards, migrations.RunPython.noop),
        migrations.RunSQL(
            forward_create_relations,
            backward_create_relations,
            [
                migrations.CreateModel(
                    name='VolumeClassInstance',
                    fields=[
                        ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                        ('creation_time', models.DateTimeField(default=django.utils.timezone.now)),
                        ('edition_time', models.DateTimeField(default=django.utils.timezone.now)),
                        ('class_instance', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='catmaid.ClassInstance')),
                        ('project', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='catmaid.Project')),
                        ('relation', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='catmaid.Relation')),
                        ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                        ('volume', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='catmaid.Volume')),
                    ],
                    options={
                        'db_table': 'volume_class_instance',
                    },
                ),
            ]
        ),
    ]
